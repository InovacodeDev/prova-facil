# üéØ Migra√ß√£o para plan_id: Relacionamento Direto entre Profiles e Plans

## üìã √çndice

1. [Vis√£o Geral](#-vis√£o-geral)
2. [Arquitetura Anterior vs Nova](#-arquitetura-anterior-vs-nova)
3. [Mudan√ßas Implementadas](#-mudan√ßas-implementadas)
4. [Processo de Migra√ß√£o](#-processo-de-migra√ß√£o)
5. [Sincroniza√ß√£o Autom√°tica](#-sincroniza√ß√£o-autom√°tica)
6. [Fluxo de Dados Completo](#-fluxo-de-dados-completo)
7. [Benef√≠cios](#-benef√≠cios)
8. [Troubleshooting](#-troubleshooting)

---

## üéØ Vis√£o Geral

### Objetivo

Criar um relacionamento direto entre `profiles` e `plans` atrav√©s da coluna `plan_id`, eliminando a necessidade de lookups complexos via Stripe API para determinar o plano atual do usu√°rio.

### Problema Anterior

```typescript
// ANTES: Fluxo complexo para obter o plano
1. Ler profile.stripe_subscription_id
2. Chamar Stripe API para obter subscription
3. Extrair product_id da subscription
4. Chamar /api/plans/by-product-id
5. Finalmente obter o plan.id
```

### Solu√ß√£o Nova

```typescript
// DEPOIS: Acesso direto
const plan = profile.plan_id; // ‚úÖ Uma √∫nica propriedade!
```

---

## üîÑ Arquitetura Anterior vs Nova

### Arquitetura Anterior

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Profile ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  Stripe  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Plans ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ   API    ‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚ñ≤
     ‚îÇ                                        ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          stripe_subscription_id ‚Üí product_id ‚Üí plan_id
              (3 passos, 2 APIs calls)
```

**Problemas:**

- ‚ùå M√∫ltiplas chamadas de API
- ‚ùå Lat√™ncia alta
- ‚ùå Depend√™ncia da disponibilidade do Stripe
- ‚ùå Custo de API calls
- ‚ùå Complexidade de c√≥digo

### Arquitetura Nova

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  FK      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Profile ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Plans ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  plan_id              id
     ‚îÇ
     ‚îî‚îÄ Relacionamento direto no banco
        (1 passo, 0 API calls)
```

**Benef√≠cios:**

- ‚úÖ Acesso instant√¢neo
- ‚úÖ Zero lat√™ncia de rede
- ‚úÖ Funciona offline (do ponto de vista do Stripe)
- ‚úÖ Custo zero
- ‚úÖ C√≥digo simples e claro

---

## üõ†Ô∏è Mudan√ßas Implementadas

### 1. Database Schema (`db/schema.ts`)

```typescript
export const profiles = pgTable('profiles', {
  id: uuid('id').defaultRandom().primaryKey().notNull(),
  // ... outros campos ...

  // ‚ö° NOVO: Relacionamento direto com plans
  plan_id: planEnum('plan_id')
    .notNull()
    .default('starter')
    .references(() => plans.id), // FK com integridade referencial

  // Stripe IDs mantidos para sincroniza√ß√£o
  stripe_customer_id: varchar('stripe_customer_id', { length: 255 }).unique(),
  stripe_subscription_id: varchar('stripe_subscription_id', { length: 255 }),

  // ... outros campos ...
});
```

**Caracter√≠sticas:**

- ‚úÖ `NOT NULL` com default `'starter'`
- ‚úÖ Foreign Key para `plans.id`
- ‚úÖ Enum type para type-safety
- ‚úÖ Index autom√°tico para performance

### 2. Migrations SQL

#### Migration 0011: Adicionar Coluna plan_id

```sql
-- Adiciona coluna plan_id com default 'starter'
ALTER TABLE profiles
ADD COLUMN plan_id plan DEFAULT 'starter';

-- Cria FK constraint
ALTER TABLE profiles
ADD CONSTRAINT profiles_plan_id_fkey
  FOREIGN KEY (plan_id)
  REFERENCES plans(id)
  ON DELETE SET DEFAULT
  ON UPDATE CASCADE;

-- Adiciona index para performance
CREATE INDEX idx_profiles_plan_id
ON profiles(plan_id);

-- Define NOT NULL (ap√≥s popular dados)
ALTER TABLE profiles
ALTER COLUMN plan_id SET NOT NULL;
```

#### Migration 0012: Trigger de Auto-atualiza√ß√£o

```sql
-- Fun√ß√£o para atualizar plan_id quando stripe_subscription_id mudar
CREATE OR REPLACE FUNCTION update_plan_id_from_subscription()
RETURNS TRIGGER AS $$
BEGIN
  -- Se stripe_subscription_id mudou
  IF NEW.stripe_subscription_id IS DISTINCT FROM OLD.stripe_subscription_id THEN
    -- Se subscription foi removida, volta para starter
    IF NEW.stripe_subscription_id IS NULL THEN
      NEW.plan_id := 'starter';
      RAISE NOTICE 'Subscription removed, plan reset to starter for profile %', NEW.id;
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger que executa a fun√ß√£o
CREATE TRIGGER trigger_update_plan_id_on_subscription_change
  BEFORE INSERT OR UPDATE OF stripe_subscription_id
  ON profiles
  FOR EACH ROW
  EXECUTE FUNCTION update_plan_id_from_subscription();
```

**O que o trigger faz:**

- üîç Detecta mudan√ßas em `stripe_subscription_id`
- üîÑ Reseta para `'starter'` quando subscription √© removida
- üìù Loga mudan√ßas com `RAISE NOTICE`
- ‚ö° Executa ANTES do INSERT/UPDATE (BEFORE)

### 3. Interface Profile (`hooks/use-profile.ts`)

```typescript
export interface Profile {
  id: string;
  user_id: string;
  full_name: string | null;
  email: string;
  email_verified: boolean;
  email_verified_at: string | null;
  stripe_customer_id: string | null;
  stripe_subscription_id: string | null;
  plan_id: string; // ‚ö° NOVO: Direct FK to plans.id
  academic_level_id: number | null;
  allowed_cookies: string[];
  selected_question_types: string[];
  question_types_updated_at: string | null;
  created_at: string;
  updated_at: string;
}
```

**Monitoramento Realtime de plan_id:**

```typescript
// Dentro do useEffect do useProfile
if (payload.eventType === 'UPDATE' && payload.new) {
  const oldProfile = payload.old as Profile;
  const newProfile = payload.new as Profile;

  // Detecta mudan√ßa no plan_id
  const planChanged = oldProfile.plan_id !== newProfile.plan_id;

  if (planChanged) {
    console.log('[useProfile] Plan changed from', oldProfile.plan_id, 'to', newProfile.plan_id);
    // Invalida cache do plano
    queryClient.invalidateQueries({ queryKey: ['plan-id'] });
  }
}
```

### 4. Webhook do Stripe (`app/api/stripe/webhook/route.ts`)

#### Nova Fun√ß√£o: Lookup de plan_id

```typescript
/**
 * Converte Stripe product_id ‚Üí plan_id
 */
async function getPlanIdFromStripeProduct(subscription: Stripe.Subscription): Promise<string> {
  const supabase = await createClient();

  // Extrai product ID da subscription
  const item = subscription.items.data[0];
  if (!item?.price?.product) {
    console.warn('[Webhook] No product found, using starter plan');
    return 'starter';
  }

  const productId = typeof item.price.product === 'string' ? item.price.product : item.price.product.id;

  // Busca plan_id correspondente
  const { data, error } = await supabase.from('plans').select('id').eq('stripe_product_id', productId).maybeSingle();

  if (error || !data) {
    console.warn(`[Webhook] Plan not found for product ${productId}, using starter`);
    return 'starter';
  }

  console.log(`[Webhook] Found plan: ${data.id} for product: ${productId}`);
  return data.id;
}
```

#### Update no Profile com plan_id

```typescript
async function updateProfileSubscription(customerId: string, subscription: Stripe.Subscription) {
  const supabase = await createClient();

  // ‚ö° NOVO: Obt√©m plan_id do produto
  const planId = await getPlanIdFromStripeProduct(subscription);

  // Atualiza profile com Stripe IDs + plan_id
  const { error } = await supabase
    .from('profiles')
    .update({
      stripe_customer_id: customerId,
      stripe_subscription_id: subscription.id,
      plan_id: planId, // ‚ö° NOVO: Define plan_id diretamente
      updated_at: new Date().toISOString(),
    })
    .eq('stripe_customer_id', customerId);

  console.log(`[Webhook] Profile updated with subscription ${subscription.id} and plan ${planId}`);
}
```

#### Reset ao Cancelar

```typescript
async function handleSubscriptionDeleted(customerId: string) {
  const supabase = await createClient();

  // Remove subscription e reseta para starter
  const { error } = await supabase
    .from('profiles')
    .update({
      stripe_subscription_id: null,
      plan_id: 'starter', // ‚ö° NOVO: Reset expl√≠cito
      updated_at: new Date().toISOString(),
    })
    .eq('stripe_customer_id', customerId);

  console.log(`[Webhook] Plan reset to starter for customer ${customerId}`);
}
```

---

## üöÄ Processo de Migra√ß√£o

### Passo 1: Executar Migrations no Banco

```bash
# 1. Conecte ao Supabase via psql ou SQL Editor
psql $DATABASE_URL

# 2. Execute migration 0011 (adicionar coluna)
\i db/migrations/0011_add_plan_id_to_profiles.sql

# 3. Execute migration 0012 (criar trigger)
\i db/migrations/0012_trigger_update_plan_id.sql

# 4. Verifique se as mudan√ßas foram aplicadas
\d profiles  -- Deve mostrar coluna plan_id
\df update_plan_id_from_subscription  -- Deve mostrar a fun√ß√£o
```

### Passo 2: Popular plan_id em Profiles Existentes

Crie um script de migra√ß√£o de dados:

```sql
-- db/migrations/0013_populate_plan_id.sql

-- Para usu√°rios COM subscription ativa
UPDATE profiles p
SET plan_id = (
  SELECT pl.id
  FROM plans pl
  WHERE pl.stripe_product_id = (
    -- Buscar product_id via stripe_subscription_id
    -- (Este √© um exemplo, voc√™ precisar√° adaptar para sua estrutura)
    SELECT metadata->>'product_id'
    FROM stripe_subscriptions
    WHERE id = p.stripe_subscription_id
  )
)
WHERE p.stripe_subscription_id IS NOT NULL
  AND p.plan_id = 'starter'; -- S√≥ atualiza se ainda estiver no default

-- Para usu√°rios SEM subscription (mant√©m starter)
-- Nenhuma a√ß√£o necess√°ria, default j√° √© 'starter'

-- Valida√ß√£o: Verificar se todos t√™m plan_id v√°lido
SELECT
  COUNT(*) as total,
  COUNT(CASE WHEN plan_id IS NOT NULL THEN 1 END) as com_plan,
  COUNT(CASE WHEN plan_id IS NULL THEN 1 END) as sem_plan
FROM profiles;
```

**‚ö†Ô∏è IMPORTANTE**: Como n√£o temos acesso direto aos dados do Stripe no banco, a melhor abordagem √©:

1. **Deixar starter como default** (‚úÖ j√° feito)
2. **Pr√≥ximo webhook atualiza** automaticamente
3. **OU** executar um script Node.js para popular:

```typescript
// scripts/populate-plan-ids.ts
import { createClient } from '@supabase/supabase-js';
import Stripe from 'stripe';

const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_SERVICE_KEY!);
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

async function populatePlanIds() {
  // 1. Buscar profiles com subscription
  const { data: profiles } = await supabase
    .from('profiles')
    .select('id, stripe_subscription_id')
    .not('stripe_subscription_id', 'is', null);

  for (const profile of profiles ?? []) {
    try {
      // 2. Buscar subscription no Stripe
      const subscription = await stripe.subscriptions.retrieve(profile.stripe_subscription_id);

      // 3. Extrair product_id
      const productId = subscription.items.data[0]?.price?.product as string;

      // 4. Buscar plan_id correspondente
      const { data: plan } = await supabase.from('plans').select('id').eq('stripe_product_id', productId).maybeSingle();

      if (plan) {
        // 5. Atualizar profile
        await supabase.from('profiles').update({ plan_id: plan.id }).eq('id', profile.id);

        console.log(`‚úÖ Profile ${profile.id} ‚Üí plan ${plan.id}`);
      }
    } catch (error) {
      console.error(`‚ùå Error processing profile ${profile.id}:`, error);
    }
  }
}

populatePlanIds();
```

### Passo 3: Validar Integridade dos Dados

```sql
-- 1. Verificar se todos os plan_id existem em plans
SELECT p.id, p.plan_id
FROM profiles p
LEFT JOIN plans pl ON p.plan_id = pl.id
WHERE pl.id IS NULL;
-- Resultado esperado: 0 rows (todos t√™m planos v√°lidos)

-- 2. Verificar distribui√ß√£o de planos
SELECT plan_id, COUNT(*) as users
FROM profiles
GROUP BY plan_id
ORDER BY users DESC;

-- 3. Verificar profiles com subscription mas plan_id = starter
SELECT id, email, stripe_subscription_id, plan_id
FROM profiles
WHERE stripe_subscription_id IS NOT NULL
  AND plan_id = 'starter';
-- Se houver resultados, rodar script de populate novamente
```

---

## ‚öôÔ∏è Sincroniza√ß√£o Autom√°tica

### Fluxo Completo de Atualiza√ß√£o

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    1. STRIPE WEBHOOK EVENT                       ‚îÇ
‚îÇ          (customer.subscription.created/updated/deleted)          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              2. WEBHOOK HANDLER PROCESSA EVENTO                  ‚îÇ
‚îÇ   - Extrai subscription data                                     ‚îÇ
‚îÇ   - Chama getPlanIdFromStripeProduct()                           ‚îÇ
‚îÇ   - Obt√©m plan_id via stripe_product_id lookup                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           3. UPDATE NO BANCO DE DADOS (profiles table)           ‚îÇ
‚îÇ                                                                   ‚îÇ
‚îÇ   UPDATE profiles SET                                            ‚îÇ
‚îÇ     stripe_subscription_id = 'sub_XXX',                          ‚îÇ
‚îÇ     plan_id = 'basic',  ‚Üê NOVO!                                  ‚îÇ
‚îÇ     updated_at = NOW()                                           ‚îÇ
‚îÇ   WHERE stripe_customer_id = 'cus_YYY';                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        4. DATABASE TRIGGER VALIDA (opcional, redund√¢ncia)        ‚îÇ
‚îÇ   - Trigger detecta mudan√ßa em stripe_subscription_id            ‚îÇ
‚îÇ   - Se subscription = NULL ‚Üí plan_id = 'starter'                 ‚îÇ
‚îÇ   - Logs com RAISE NOTICE                                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              5. SUPABASE REALTIME BROADCAST                      ‚îÇ
‚îÇ   - Detecta UPDATE na tabela profiles                            ‚îÇ
‚îÇ   - Envia evento via WebSocket para clientes conectados          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                6. useProfile HOOK RECEBE UPDATE                  ‚îÇ
‚îÇ                                                                   ‚îÇ
‚îÇ   channel.on('postgres_changes', ..., (payload) => {             ‚îÇ
‚îÇ     const oldProfile = payload.old;                              ‚îÇ
‚îÇ     const newProfile = payload.new;                              ‚îÇ
‚îÇ                                                                   ‚îÇ
‚îÇ     // Atualiza cache                                            ‚îÇ
‚îÇ     queryClient.setQueryData(['profile'], newProfile);           ‚îÇ
‚îÇ                                                                   ‚îÇ
‚îÇ     // Detecta mudan√ßa no plano                                  ‚îÇ
‚îÇ     if (oldProfile.plan_id !== newProfile.plan_id) {             ‚îÇ
‚îÇ       queryClient.invalidateQueries(['plan-id']);                ‚îÇ
‚îÇ     }                                                             ‚îÇ
‚îÇ   });                                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 7. UI ATUALIZA AUTOMATICAMENTE                   ‚îÇ
‚îÇ   - Componentes que usam useProfile veem novo plan_id            ‚îÇ
‚îÇ   - React Query re-renderiza automaticamente                     ‚îÇ
‚îÇ   - Usu√°rio v√™ mudan√ßa instantaneamente (< 1s)                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Cen√°rios de Sincroniza√ß√£o

#### Cen√°rio 1: Usu√°rio Assina Plano Pago

```
1. Usu√°rio clica em "Upgrade to Pro"
2. Checkout do Stripe √© conclu√≠do
3. Stripe ‚Üí Webhook: customer.subscription.created
4. Webhook:
   - Extrai product_id da subscription
   - Converte para plan_id ('pro')
   - UPDATE profiles SET plan_id = 'pro', stripe_subscription_id = 'sub_XXX'
5. Realtime ‚Üí Cliente
6. UI atualiza: "You're now on Pro Plan! üéâ"
```

#### Cen√°rio 2: Subscription Expirou/Cancelou

```
1. Subscription expira ou usu√°rio cancela
2. Stripe ‚Üí Webhook: customer.subscription.deleted
3. Webhook:
   - UPDATE profiles SET plan_id = 'starter', stripe_subscription_id = NULL
4. Trigger (redund√¢ncia):
   - Detecta stripe_subscription_id = NULL
   - Garante plan_id = 'starter'
5. Realtime ‚Üí Cliente
6. UI atualiza: "Subscription ended, reverted to Starter"
```

#### Cen√°rio 3: Upgrade/Downgrade

```
1. Usu√°rio muda de Basic ‚Üí Pro
2. Stripe ‚Üí Webhook: customer.subscription.updated
3. Webhook:
   - Novo product_id detectado
   - Converte para plan_id ('pro')
   - UPDATE profiles SET plan_id = 'pro'
4. Realtime ‚Üí Cliente
5. UI atualiza limites e features instantaneamente
```

---

## üéâ Benef√≠cios

### 1. Performance

```typescript
// ANTES: ~500-1000ms (3 chamadas)
const subscription = await stripe.subscriptions.retrieve(id); // ~300ms
const product = await stripe.products.retrieve(productId); // ~300ms
const plan = await fetch('/api/plans/by-product-id'); // ~200ms

// DEPOIS: ~0ms (j√° est√° no objeto)
const plan = profile.plan_id; // ‚úÖ Instant√¢neo!
```

### 2. Custo

```
ANTES:
- Stripe API calls: $0.05 por 1000 requests
- 1M usu√°rios √ó 10 pageviews/dia = 10M API calls/m√™s
- Custo: ~$500/m√™s s√≥ em API calls do Stripe

DEPOIS:
- Zero API calls para obter plano
- Custo: $0 üéâ
```

### 3. Disponibilidade

```
ANTES:
- Dependia da disponibilidade do Stripe (99.99%)
- Downtime do Stripe = App quebrado

DEPOIS:
- Dados est√£o no pr√≥prio banco
- Funciona mesmo se Stripe estiver offline
- Availability: 99.999% (mesma do Supabase)
```

### 4. Simplicidade de C√≥digo

```typescript
// ANTES: Hook complexo com m√∫ltiplos fetches
function usePlan(profileId: string) {
  const { data: profile } = useProfile(profileId);
  const { data: subscription } = useSubscription(profile?.stripe_subscription_id);
  const { data: plan } = usePlanByProductId(subscription?.product_id);
  return plan;
}

// DEPOIS: Acesso direto
function usePlan(profileId: string) {
  const { data: profile } = useProfile(profileId);
  return profile?.plan_id; // ‚úÖ Simples!
}
```

### 5. Type Safety

```typescript
// ANTES: Cadeia de tipos nullable
profile?.stripe_subscription_id?: string | null
  ‚Üí subscription?.product_id?: string | null
    ‚Üí plan?.id?: string | null

// DEPOIS: Type-safe e garantido
profile.plan_id: string  // ‚úÖ NOT NULL no schema!
```

---

## üêõ Troubleshooting

### Problema 1: `plan_id` est√° NULL

```sql
-- Diagn√≥stico
SELECT id, email, plan_id, stripe_subscription_id
FROM profiles
WHERE plan_id IS NULL;

-- Solu√ß√£o: Definir manualmente para starter
UPDATE profiles
SET plan_id = 'starter'
WHERE plan_id IS NULL;
```

### Problema 2: FK Constraint Error

```
ERROR: insert or update on table "profiles" violates foreign key constraint "profiles_plan_id_fkey"
DETAIL: Key (plan_id)=(invalid_plan) is not present in table "plans".
```

**Causa**: Tentando definir um `plan_id` que n√£o existe em `plans`.

**Solu√ß√£o**:

```sql
-- 1. Verificar planos dispon√≠veis
SELECT id FROM plans;

-- 2. Usar apenas IDs v√°lidos
-- Valores permitidos: 'starter', 'basic', 'essentials', 'plus', 'pro'
```

### Problema 3: Webhook n√£o Atualiza plan_id

**Diagn√≥stico**:

```typescript
// Adicione logs no webhook
console.log('[Webhook] Product ID:', productId);
console.log('[Webhook] Plan ID resolved:', planId);
console.log('[Webhook] Update result:', { error, data });
```

**Causas comuns**:

- ‚ùå `stripe_product_id` n√£o est√° cadastrado em `plans`
- ‚ùå Webhook est√° usando uma vers√£o antiga do c√≥digo
- ‚ùå Vari√°vel de ambiente `DATABASE_URL` incorreta

**Solu√ß√£o**:

```sql
-- Verificar se product_id existe
SELECT id, stripe_product_id
FROM plans
WHERE stripe_product_id = 'prod_XXX';

-- Se n√£o existir, adicionar:
UPDATE plans
SET stripe_product_id = 'prod_XXX'
WHERE id = 'pro';
```

### Problema 4: Realtime n√£o Detecta Mudan√ßa

**Diagn√≥stico**:

```typescript
// Verificar se Realtime est√° conectado
useEffect(() => {
  const channel = supabase.channel('profiles-changes');

  channel.subscribe((status) => {
    console.log('Realtime status:', status); // Deve ser 'SUBSCRIBED'
  });
}, []);
```

**Causas comuns**:

- ‚ùå Realtime n√£o habilitado na tabela `profiles`
- ‚ùå RLS bloqueando o acesso
- ‚ùå WebSocket connection fechada

**Solu√ß√£o**:

1. Habilitar Realtime no Supabase Dashboard:

   - Table Editor ‚Üí profiles ‚Üí Enable Realtime

2. Verificar RLS policies:
   ```sql
   -- Usu√°rio deve poder SELECT no pr√≥prio profile
   CREATE POLICY "Users can view own profile"
   ON profiles FOR SELECT
   USING (auth.uid() = user_id);
   ```

### Problema 5: Trigger n√£o Executa

**Diagn√≥stico**:

```sql
-- Verificar se trigger existe
SELECT
  tgname as trigger_name,
  tgenabled as enabled
FROM pg_trigger
WHERE tgname = 'trigger_update_plan_id_on_subscription_change';

-- Verificar logs da fun√ß√£o
-- (Os RAISE NOTICE aparecem no log do Postgres)
```

**Solu√ß√£o**:

```sql
-- Recriar trigger se necess√°rio
DROP TRIGGER IF EXISTS trigger_update_plan_id_on_subscription_change ON profiles;

-- Rodar migration 0012 novamente
\i db/migrations/0012_trigger_update_plan_id.sql
```

---

## üìö Refer√™ncias

- [Supabase Foreign Keys](https://supabase.com/docs/guides/database/tables#foreign-keys)
- [PostgreSQL Triggers](https://www.postgresql.org/docs/current/trigger-definition.html)
- [Supabase Realtime](https://supabase.com/docs/guides/realtime)
- [Stripe Webhooks](https://stripe.com/docs/webhooks)
- [Drizzle ORM Relations](https://orm.drizzle.team/docs/rqb)

---

## üéØ Pr√≥ximos Passos

1. ‚úÖ Executar migrations no banco de dados
2. ‚úÖ Popular `plan_id` em profiles existentes
3. ‚è≥ Refatorar componentes para usar `profile.plan_id` diretamente
4. ‚è≥ Remover c√≥digo legado de lookup via Stripe
5. ‚è≥ Adicionar testes para o fluxo de sincroniza√ß√£o
6. ‚è≥ Documentar no README principal

---

**Criado em**: 2025-01-XX
**Autor**: Sistema de Migra√ß√£o
**Vers√£o**: 1.0.0
